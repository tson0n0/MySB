#!/bin/bash
# ----------------------------------
#  __/\\\\____________/\\\\___________________/\\\\\\\\\\\____/\\\\\\\\\\\\\___
#   _\/\\\\\\________/\\\\\\_________________/\\\/////////\\\_\/\\\/////////\\\_
#	_\/\\\//\\\____/\\\//\\\____/\\\__/\\\__\//\\\______\///__\/\\\_______\/\\\_
#	 _\/\\\\///\\\/\\\/_\/\\\___\//\\\/\\\____\////\\\_________\/\\\\\\\\\\\\\\__
#	  _\/\\\__\///\\\/___\/\\\____\//\\\\\________\////\\\______\/\\\/////////\\\_
#	   _\/\\\____\///_____\/\\\_____\//\\\____________\////\\\___\/\\\_______\/\\\_
#		_\/\\\_____________\/\\\__/\\_/\\\______/\\\______\//\\\__\/\\\_______\/\\\_
#		 _\/\\\_____________\/\\\_\//\\\\/______\///\\\\\\\\\\\/___\/\\\\\\\\\\\\\/__
#		  _\///______________\///___\////__________\///////////_____\/////////////_____
#			By toulousain79 ---> https://github.com/toulousain79/
#
######################################################################
#
#	Copyright (c) 2013 toulousain79 (https://github.com/toulousain79/)
#	Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:
#	The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
#	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
#	IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
#	--> Licensed under the MIT license: http://www.opensource.org/licenses/mit-license.php
#
######################################################################
#
# Public Resolver List: https://dnscrypt.org/dnscrypt-resolvers.html
# Progress Bar - https://github.com/fearside/ProgressBar/
#
# This init script was greatly inspired by DNSCrypt-Loader: https://github.com/GortCodex/DNSCrypt-Loader
#
##################### FIRST LINE #####################################

### BEGIN INIT INFO
# Provides:		  dnscrypt
# Required-Start:	$remote_fs $network $mysql
# Required-Stop:	 $remote_fs $network $mysql
# Default-Start:	 2 3 4 5
# Default-Stop:	  0 1 6
# Short-Description: Start DNScrypt-proxy
# Description:	   Encrypt DNS queries.
### END INIT INFO

#### Includes
# shellcheck source=.etc/MySB/config
. /etc/MySB/config || exit 0
# shellcheck source=inc/vars
. "$MySB_InstallDir/inc/vars" || exit 0

######################################################################
#
# S T A R T   C U S T O M I Z A T I O N S
#
######################################################################

#------------------------------------------------------------
# DNScrypt-proxy infos
#------------------------------------------------------------
gsProxyName="dnscrypt-proxy" # bin name
gsProxyDesc="DNScrypt-proxy" # description
gsProxyDir="/usr/local/sbin" # bin name directory
gsProxyBin="$gsProxyDir/$gsProxyName" # full path to bin name
gsLogFile="/var/log/$gsProxyName.log" # log file
gsPidDir="/var/run/$gsProxyName" # pid directory
gsWorkDir="/usr/local/share/$gsProxyName" # default working directory
gsTmpDir="/tmp/$gsProxyName" # temp directory
gsRootUrl="https://raw.githubusercontent.com/toulousain79/MySB/v99.99/files/dnscrypt-resolvers" # Root URL for CSV, minisign and PUB files
#------------------------------------------------------------
# Chroot user who executes dnscrypt-proxy, please change root user by unprivileged user to avoid security problems
#------------------------------------------------------------
gsDeamonUser="dnscrypt"
#------------------------------------------------------------
# dnscrypt-resolvers.csv
#------------------------------------------------------------
gsCsvName="dnscrypt-resolvers.csv"
gsCsvFile="$gsWorkDir/$gsCsvName"
gsCsvUrl="$gsRootUrl/$gsCsvName"
#------------------------------------------------------------
# dnscrypt-resolvers.csv.minisig
#------------------------------------------------------------
gsSigName="dnscrypt-resolvers.csv.minisig"
gsSigFile="$gsWorkDir/$gsSigName"
gsSigUrl="$gsRootUrl/$gsSigName"
#------------------------------------------------------------
# minisign.pub
#------------------------------------------------------------
gsPubKeyName="minisign.pub"
gsPubKeyFile="$gsWorkDir/$gsPubKeyName"
gsPubKeyUrl="$gsRootUrl/$gsPubKeyName"
#------------------------------------------------------------
# IP version of resolvers to used
#	Options:
#	"ipv4" = show only ipv4 resolvers (default)
#	"ipv6" = show only ipv6 resolvers
#	"all"  = show ipv4 and ipv6 resolvers
#------------------------------------------------------------
gsIpVersion="ipv4"
#------------------------------------------------------------
# Number of DNScrypt-proxy processes wished
#	Options:
#	"N"	= Where N is a number from 1 to 6 (default: 2)
#------------------------------------------------------------
gnNumberOfDaemon=4
#------------------------------------------------------------
# Selection mode of resolvers
#	Options:
#	"yes"	= resolvers will selected randomly
#	"no"	= resolvers will selected by DNS speed time
#------------------------------------------------------------
gbRandomResolvers=no
#------------------------------------------------------------
# Resolvers filers: Logs (no privacy) or No Logs (privacy)
#	gbOnlyNoLogs = yes	--> No Logs (privacy): display only anonymous resolvers (default and recommended)
#	gbOnlyNoLogs = no		--> Logs (no privacy): display all resolvers
#	gbOnlyDNSSec = yes	--> DNSsec support: display only DNSsec compatible resolvers (default and recommended)
#	gbOnlyDNSSec = no		--> DNSsec support: display all resolvers
#	gbOnlyNameCoin = yes	--> NameCoin support: display only NameCoin compatible resolvers (default and recommended)
#	gbOnlyNameCoin = no	--> NameCoin support: display all resolvers
#------------------------------------------------------------
gbOnlyNoLogs=yes
gbOnlyDNSSec=no
gbOnlyNameCoin=no
#------------------------------------------------------------
# User interface
#	whiptail or dialog
#------------------------------------------------------------
gsGUI="whiptail"
#------------------------------------------------------------
# Service locked ?
#------------------------------------------------------------
gbLockStart="`cmdMySQL 'MySB_db' "SELECT dnscrypt FROM system WHERE id_system='1';"`"
#------------------------------------------------------------
# CSV file 'dnscrypt-resolvers.csv' compile
#------------------------------------------------------------
gsCplAllCsvUrls="https://raw.githubusercontent.com/toulousain79/MySB/v5.3/files/dnscrypt-resolvers/archives/20180529-1516.csv
https://raw.githubusercontent.com/toulousain79/MySB/v5.3/files/dnscrypt-resolvers/archives/20190105-1509.csv
https://raw.githubusercontent.com/dyne/dnscrypt-proxy/master/dnscrypt-resolvers.csv
https://gist.githubusercontent.com/legendtang/db7265c5f5f82c9aed70/raw/5fc8bbc6d0acf7a0da5f5be7f5b7b7e243ec8931/dnscrypt-resolvers.csv
https://raw.githubusercontent.com/cryptostorm/cstorm_deepDNS/master/dnscrypt-resolvers.csv
https://svn.dd-wrt.com/export/38136/src/router/dnscrypt/dnscrypt-resolvers.csv
https://git.telliq.com/gtu/packages/raw/d29bddd8093133aa1dfe42f35353d079b7d73f1e/net/dnscrypt-proxy/files/dnscrypt-resolvers.csv?inline=false"
# DO NOT add the dead list others because of an empty first line !!!
gsCplDeadResolversList="https://raw.githubusercontent.com/toulousain79/MySB/v5.3/files/dnscrypt-resolvers/dead-resolvers.csv"
# Directories
gsCplDestDir="/opt/DNScrypt-proxy"
gsCplTmpDir="$gsCplDestDir/tmp"
# Files name
gsCplFinalCsv="${gsCplDestDir}/$gsCsvName"
gsCplMinisignPubKey="${gsCplDestDir}/$gsPubKeyName"
gsCplMinisignPrivKey="$(getent passwd "$(whoami)" | cut -d: -f6)/.minisign/minisign.key"
# CSV header
gsCplFirstLine='Name,"Full name","Description","Location","Coordinates","URL","Version","DNSSEC validation","No logs","Namecoin","Resolver address","Provider name","Provider public key","Provider public key TXT record"'
# Timing
gdCplDate=$(date +%Y%m%d)
gdCplTime=$(date +%H%M)
gdCplDateFormated=$(date +%Y-%m-%d)
gdCplTimeFormated=$(date +%H:%M)
gsCplMessage="Released date: ${gdCplDateFormated}-${gdCplTimeFormated}"

######################################################################
#
# From here begins the main script code.
# You do not need to customize anything here.
#
######################################################################

######################################################################
#
# E N D   C U S T O M I Z A T I O N S
#
######################################################################

######################################################################
#
# S T A R T   W O R K S P A C E
#
######################################################################

#------------------------------------------------------------
# Functions - Begin
#------------------------------------------------------------
# Checking prerequisites
gfnCheckPrerequisites() {
	local nExit sMode

	nExit=0
	sMode=''

	# User privileges
	if [ "$(id -u)" -ne 0 ]; then
		sMode='con'
		gsMess='\nYou need root privileges to run this script.\n'
		nExit=1
	fi

	# Check if DNScrypt-proxy is installed
	if ! gfnCheckCommand 0 $gsProxyName; then
		sMode='con'
		gsMess="\nSorry '$gsProxyName' was not found.\n"
		gsMess+="Please check if the program was installed.\n"
		nExit=1
	fi

	# Check if csvtool is installed
	if ! gfnCheckCommand 0 csvtool; then
		sMode='con'
		gsMess="\nSorry 'csvtool' was not found.\n"
		gsMess+="Please check if the program was installed.\n"
		nExit=1
	fi

	# Check if dig is installed
	if ! gfnCheckCommand mysql; then
		sMode='con'
		gsMess="\nSorry 'mysql' was not found.\n"
		gsMess+="Please check if the program was installed.\n"
		nExit=1
	fi

	# Check if whiptail is installed
	if ! gfnCheckCommand 0 whiptail; then
		gsGUI="dialog"
	fi

	if [ $nExit -eq 1 ]; then
		gfnMessage 'error' "$sMode" "$gsMess"
		exit $nExit
	fi
}

# Check files and directories
gfnCheckDirAndFiles() {
	local nReturn sProxyPath sProxyDir sCsvFile

	nReturn=0

	# set environment
	if [ ! -d $gsPidDir ]; then mkdir $gsPidDir && chown $gsDeamonUser:$gsDeamonUser $gsPidDir; fi
	if [ ! -d $gsTmpDir ]; then mkdir $gsTmpDir && chown $gsDeamonUser:$gsDeamonUser $gsTmpDir; fi

	# Path conflict?
	sProxyPath="`which $gsProxyDir/$gsProxyName`"
	sProxyDir="`dirname $sProxyPath`"
	if [ "$sProxyDir" != "$gsProxyDir" ]; then
		gsMess="\nThe $sProxyPath path on this init script differs from $gsProxyDesc setup.\n"
		gsMess+="Please change 'gsProxyDir' parameter to:\n"
		gsMess+="	gsProxyDir='$sProxyDir'\n"
		gsMess+="in\n"
		gsMess+="	'$0'\n"

		gfnMessage 'error' 'con' "$gsMess"
		nReturn=1
	fi

	# file found or empty ?
	if [ ! -e $gsCsvFile ] || [ ! -s $gsCsvFile ]; then
		gsMess="\nFile '$gsCsvName' not found or empty.\n"
		gsMess+="Please do an update option from menu OR by command line to download a new version from official source.\n"
		gsMess+="	service $gsProxyName update\n"

		gfnMessage 'error' 'con' "$gsMess"
	fi

	return $nReturn
}

# Check resolvers certificate validity
gfnCheckCertificateValidity() {
	local sResolversList sType nCount sResolverGiven sListToRead

	sResolverGiven="$1"
	sListToRead="$gsResolversList"
	nCount=1

	if [ -n "$sResolverGiven" ] && [ -n "`echo $gsResolversList | grep "$sResolverGiven"`" ]; then
		sListToRead="$sResolverGiven"
	fi

	for sResolver in $sListToRead; do
		gfnMessage "notice" 'log' "Checking certificate for: '$sResolver'"

		[ "$gbShowMessages" == yes ] && gfnProgressBar -s $nCount -e $gnCountResolver -t 'Checking certificate			:' -m "($nCount/$gnCountResolver	- $sResolver)"

		eval "${gsProxyBin} -R ${sResolver} -t ${gnProxyTestMargin} -u ${gsDeamonUser} -L ${gsCsvFile} -l ${gsTmpDir}/${sResolver}.log -m 7 >> ${gsTmpDir}/${sResolver}.log 2>&1"
		gnCertificate=$?

		case "$gnCertificate" in
			0) #  a valid certificate can be used
				sType='info'
				gsMess="A valid certificate can be used"
				cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET certificate='$gnCertificate', comments='$gsMess' WHERE name='$sResolver';"
				if [ -z "$sResolverGiven" ]; then
					sResolversList="$sResolversList $sResolver"
				fi
			;;
			*)
				sType='warning'
				case "$gnCertificate" in
					2)	gsMess="No valid certificates can be used";;
					3)	gsMess="A timeout occurred";;
					4)	gsMess="A currently valid certificate is going to expire before margin $gnProxyTestMargin";;
					*) # ???
						sType='error'
						gsMess="An unknow error occurred: $gnCertificate"
					;;
				esac

				cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET forwarder='', certificate='$gnCertificate', pid='', comments='$gsMess' WHERE name='$sResolver';"
			;;
		esac

		case "$gbShowMessages" in
			'yes')	(( nCount++ ));;
			'no')	return $gnCertificate;;
		esac

		gfnMessage "$sType" 'log' "$gsMess for: '$sResolver'"
	done

	gsResolversList="`echo $sResolversList | sed -e 's/^ //g;' | sed 's/\s+$//'`"
	gnCountResolver="`echo $gsResolversList | wc -w`"
}

#------------------------------------------------------------
# DNS LEAK TEST (IPv4)
#
# This function is just a command line bonus. It depends of third party software that can change any time.
#
# Note: DNS-OARC is not a DNS Leak Test site itself but produces the exactly same results when we observe the DNS Servers tested
# This site was chosen because is secure and it does not use javascript, permitting download of data inside html code
#
#
# No magic here. This function extracts the DNS IP addresses detected on entropy.dns-oarc.net/test test page.
# So you can check if the DNSCrypt-proxy resolvers you choosed really is working.
#
# But the most important is verify if your real IP address is listed.
# If yes, it means you are not protected by VPN or if you are using DNSCrypt-proxy as Forwarder on DNS (BIND) server,
# the directive "Forward only;"  must be applied,
# since this server will forward all requests and should not attempt to resolve requests on its own,
# bypassing DNSCrypt-proxy.
#
# Obviously, you can use DNS Leak test pages to do the same.
# Please refer to https://www.dns-oarc.net/ for details
#
#------------------------------------------------------------
gfnCheckDnsLeak() {
	local sDNSIPFilter sHTMLTestPage sDnsOarcTestURL sLeakTest sIP aIP

	sDNSIPFilter="(\\b\\name\\b\=.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}\.[[:digit:]]{1,3}.)"
	sHTMLTestPage="$gsTmpDir/dnscrypt-checkleak.html"
	sDnsOarcTestURL="entropy.dns-oarc.net/test"

	SAVEIFS=$IFS; IFS='%'

	sLeakTest=$(printf  "%-16s %s" " --- Running DNS Leak Test. Please wait ---"  " ")
	gfnMessage 'notice' 'con' "$sLeakTest"

	if [ -f $sHTMLTestPage ]; then rm -f $sHTMLTestPage; fi

	${binCURL} -o ${sHTMLTestPage} ${sDnsOarcTestURL}
	if [ -f $sHTMLTestPage ]; then
		sLeakTest=$(printf  "\n\n%-16s %s" " --- DNS Servers detected during DNS Leak Test ---"  " ")
		gfnMessage 'notice' 'con' "$sLeakTest"

		IFS=$SAVEIFS

		# Filter file by html tag and IP pattern
		sIP=$(grep -oEw "$sDNSIPFilter" $sHTMLTestPage | awk -F'"' '{print $2}')

		declare -a "aIP=($sIP)"

		for i in "${aIP[@]}"; do
			sLeakTest=$(printf  "%-16s %-16s %s\n" " Your DNS Server: " "$i" "$(dig +noall +answer +short -x $i) ")
			gfnMessage 'notice' 'con' "$sLeakTest"
		done
	fi
}

# Test resolver speed
gfnCheckDnsSpeed() {
	local sProcess sProxyIP sIp tTime sResolver sPidList sPids nProcess nCount tabAverage sType sMode nVal sDigTarget nDigTries nDigTime

	sDigTarget="internic.net"	# Domain used to test resolver
	nDigTries=2					# number of tries to resolve address
	nDigTime=2					# time in seconds per try
	sPidList="`ls -1tr $gsPidDir/`"
	nProcess="`echo $sPidList | wc -w`"
	nCount=0
	tabAverage=()
	sType='info'

	if [ "$gbShowMessages" == yes ]; then
		sMode='con'
	else
		sMode='log'
	fi

	if [ -n "$sPidList" ]; then
		gsMess="\n"

		for sPidFile in $sPidList; do
			(( nCount++ ))
			sResolver="`echo $sPidFile | sed 's/.pid//g;'`"
			sPids="`pidof $gsProxyName`"
			if [ -n "$sPids" ]; then
				sProcess=$(ps -p "$sPids" -o args= | grep "$sResolver")
				sProxyIP=$(echo $sProcess | awk '{print $5 = substr($5, 1, 100)}')
				sIp="`echo $sProxyIP | cut -d ":" -f 1`"

				[ "$gbShowMessages" == yes ] && gfnProgressBar -s $nCount -e $nProcess -t 'Speed test				:' -m "($nCount/$nProcess	- $sResolver)"

				gsMess+="Resolver name: '$sResolver'\n"
				nVal=0
				for (( i=1; i<=4; i++ )); do
					tTime=$(dig $sDigTarget +time=$nDigTime +tries=$nDigTries +noall +stats @$sIp -p 52 $gsDigProto | awk '/Query/{sum+=$4}END{print sum}')
					if [ -z $tTime ]; then
						tTime=9999
					else
						(( nVal++ ))
						tabAverage[$nVal]=$tTime
					fi
					if [ $i -eq 1 ]; then
						gsMess+="		Pass $i : $tTime msec (ignored)\n"
					else
						gsMess+="		Pass $i : $tTime msec\n"
					fi
				done

				case $nVal in
					0)	[ $tTime -eq 9999 ] && nAverage=$tTime || nAverage=000;;
					1)	let "nAverage=(${tabAverage[1]})/$nVal";;
					2)	let "nAverage=(${tabAverage[2]})/$nVal";;
					3)	let "nAverage=(${tabAverage[2]}+${tabAverage[3]})/$nVal";;
					4)	let "nAverage=(${tabAverage[2]}+${tabAverage[3]}+${tabAverage[4]})/$nVal";;
				esac
				gsMess+="		Average: $nAverage msec\n\n"

				cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET speed='$nAverage' WHERE name='$sResolver';"
			else
				sType='error'
				gsMess="Speed test canceled: no processes found for '$sPidFile'!\n"
			fi
		done
	else
		sType='notice'
		gsMess="Speed test canceled: no processes found!\n"
	fi

	[ "$gbUpdate" == no ] && gfnMessage "$sType" "$sMode" "$gsMess"
}

# Command line arguments
gfnCheckResolversWished() {
	local sWhere sResolver

	# Get resolvers list (from database)
	fnGetResolvers() {
		local sSearchByIpVersion

		case $gsIpVersion in
			'all')	sSearchByIpVersion="";;
			*)		sSearchByIpVersion=" AND ip_version='$gsIpVersion'";;
		esac

		if [ "$gbUpdate" == yes ]; then
			sWhere="dnssec='$gbOnlyDNSSec' AND no_logs='$gbOnlyNoLogs' AND namecoin='$gbOnlyNameCoin' $sSearchByIpVersion"
		else
			sWhere="dnssec='$gbOnlyDNSSec' AND no_logs='$gbOnlyNoLogs' AND namecoin='$gbOnlyNameCoin' AND certificate='0' $sSearchByIpVersion ORDER BY speed"
		fi
		gsResolversList="`cmdMySQL 'MySB_db' "SELECT name FROM dnscrypt_resolvers WHERE $sWhere;"`"
		gsResolversList="`echo $gsResolversList | sed -e 's/^ //g;' | sed 's/\s+$//'`"
		[ "$gbRandomResolvers" == yes ] && gsResolversList="`echo $gsResolversList | sort -u | xargs -n1 | sort -R | xargs`"
		gnCountResolver="`echo $gsResolversList | wc -w`"
	}
	fnGetResolvers

	if [ -n "$gsResolversList" ]; then
		for sResolver in $gsResolversList; do
			gfnMessage 'info' 'log' "Added to whish list: $sResolver"
		done
	else	# If resolvers list is empty
		gbOnlyNameCoin=no
		gfnSaveConfig 'no_display'
		gfnUpdateResolvers 'full'
		fnGetResolvers
		if [ -z "$gsResolversList" ]; then
			gsMess="\n"
			gsMess+="${gsR}No DNS resolver found !${gsN}\n"
			gsMess+="Try to update resolvers list with the following command:\n"
			gsMess+="		${gsG}service $gsProxyName full-update${gsN}\n"
			gfnMessage 'error' 'con' "$gsMess"
			exit 1
		fi
	fi
}

# Check function for cron job
gfnCheckFromCron() {
	local bRestart sPids sLookupResult
	bRestart=0

	sPids="`pidof $gsProxyName`"
	if [ -z "$sPids" ]; then
		bRestart=1
	else
		sLookupResult="`nslookup github.com | grep 'Address:' | awk '{ print $2 }' | tail -n +2 | tail -n 1`"
		if [ -z "$sLookupResult" ]; then
			bRestart=1
		fi
	fi

	[ $bRestart -eq 1 ] && gfnStop; gfnStart
}

# Show dnscrypt-proxy daemon status
gfnGetStatusDetails() {
	local sPids sMess sPidFiles nCount nCountInfos nPid sDateInit sTimeElap sProxyIP tabDnsInfo sResolverTest nSpeed

	sPids="`pidof $gsProxyName`"
	if [ -z "$sPids" ]; then
		if [ $gbLockStart -eq 0 ]; then
			gsMess="$gsProxyDesc disabled via the portal !\n"
		else
			gsMess="Warning: $gsProxyName is not running.\n"
			gsMess+="Please configure '$gsProxyName' using the following command:\n"
			gsMess+="	service $gsProxyName config\n"
		fi
		gfnMessage 'warning' 'con' "$gsMess"
		return
	fi

	sMess=$(printf   "%-16s %s" " $gsProxyDesc"   "Loaded instances" )
	sMess+=$(printf "\n\n%-16s %s" " --- Configs ---"  " " )
	sMess+=$(printf  "\n%-16s %s" " Daemon name:" "$gsProxyName" )
	sMess+=$(printf  "\n%-16s %s" " Running as:" "$gsDeamonUser" )
	sMess+=$(printf  "\n%-16s %s" " Deamon wished:" "$gnNumberOfDaemon" )
	sMess+=$(printf  "\n%-16s %s" " No Logs:" "$gbOnlyNoLogs" )
	sMess+=$(printf  "\n%-16s %s" " DNSSec:" "$gbOnlyDNSSec" )
	sMess+=$(printf  "\n%-16s %s" " NameCoin:" "$gbOnlyNameCoin" )
	sMess+=$(printf  "\n%-16s %s" " Random:" "$gbRandomResolvers" )
	sMess+=$(printf  "\n%-16s %s" " IP Version:" "$gsIpVersion" )

	declare -A tabDnsInfo
	sPidFiles="`ls -1tr $gsPidDir/`"
	if [ -n "$sPidFiles" ]; then
		for sFile in $sPidFiles; do
			sResolver="`echo $sFile | sed 's/.pid//g;'`"
			if [ -n "$sResolver" ]; then
				sPids="`pidof $gsProxyName`"
				if [ -n "$sPids" ]; then
					sProcess=$(ps -p "$sPids" -o pid= -o user= -o stime= -o etime= -o args= | grep "$sResolver")
					nSpeed="`cmdMySQL 'MySB_db' "SELECT speed FROM dnscrypt_resolvers WHERE name='$sResolver';"`"

					if [ -n "$sProcess" ]; then
						# PID
						nPid=$(		  echo $sProcess | awk '{print $1 = substr($1, 1, 100)}')
						# Date start
						sDateInit=$(	 echo $sProcess | awk '{print $3 = substr($3, 1, 100)}')
						# Elsapsed time
						sTimeElap=$(	 echo $sProcess | awk '{print $4 = substr($4, 1, 100)}')
						# Local Address
						sProxyIP=$(	  echo $sProcess | awk '{print $9 = substr($9, 1, 100)}')

						nCount="`echo $sProxyIP | cut -d ':' -f 1 | cut -d '.' -f 4`"
						nCountInfos=0
						tabDnsInfo[$nCount $nCountInfos]="$sResolver"; (( nCountInfos++ ))
						tabDnsInfo[$nCount $nCountInfos]="$nPid"; (( nCountInfos++ ))
						tabDnsInfo[$nCount $nCountInfos]="$sDateInit"; (( nCountInfos++ ))
						tabDnsInfo[$nCount $nCountInfos]="$sTimeElap"; (( nCountInfos++ ))
						tabDnsInfo[$nCount $nCountInfos]="$sProxyIP"; (( nCountInfos++ ))
						tabDnsInfo[$nCount $nCountInfos]="$nSpeed"
					fi
				fi
			fi
		done

		# Gives ordered results (DNS 1, DNS 2, DNS 3,  DNS 4)
		for (( i=1; i<=$nCount; i++ )); do
			sResolver=${tabDnsInfo[$i 0]}
			nPid=${tabDnsInfo[$i 1]}
			sDateInit=${tabDnsInfo[$i 2]}
			sTimeElap=${tabDnsInfo[$i 3]}
			sProxyIP=${tabDnsInfo[$i 4]}
			sResolverTest=${tabDnsInfo[$i 5]}

			sMess+=$(printf  "\n\n%-16s %s" " --- DNS $i ---"  " " )
			sMess+=$(printf  "\n%-16s %s" " Resolver name:" "$sResolver" )
			sMess+=$(printf  "\n%-16s %s" " Proxy IP:" "$sProxyIP" )
			sMess+=$(printf  "\n%-16s %s" " Pid:" "$nPid" )
			sMess+=$(printf  "\n%-16s %s" " Start at:" "$sDateInit (Date days-hh:mm:ss)" )
			sMess+=$(printf  "\n%-16s %s" " Execution time:" "$sTimeElap (Date days-hh:mm:ss)" )
			sMess+=$(printf  "\n%-16s %s" " Resolver test:" "$sResolverTest msec" )
		done
	else
		sMess+=$(printf  "\n%-16s %s" " No process" "found !" )
	fi

	gfnMessage 'notice' 'con' "$sMess"
}

# Do an update resolvers list
gfnUpdateResolvers() {
	local sSwitch

	sSwitch="$1"

	# Start info logs
	case "$sSwitch" in
		'full')	gfnMessage 'info' 'log' "Full update resolvers list - Start";;
		*)		gfnMessage 'info' 'log' "Basic update resolvers list - Start";;
	esac

	gbUpdate=yes
	gbShowMessages=yes
	gfnStop
	gfnDownloadCsvFile
	gfnUpdateDatabase
	if [ "$sSwitch" == "full" ]; then
		cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET certificate='0' WHERE ip_version='$gsIpVersion' AND dnssec='$gbOnlyDNSSec' AND no_logs='$gbOnlyNoLogs' AND namecoin='$gbOnlyNameCoin';"
		gfnCheckResolversWished
		gfnCheckCertificateValidity
		gfnCheckResolversWished
		gfnStop
		gfnStart
		gfnCheckDnsSpeed
		gfnStop
		gbUpdate=no
		log_daemon_msg "Starting $gsProxyDesc" "$gsProxyName"
		gfnStart
		# Return
		# 0	: if daemon could not be started
		# 1+	: if daemon has been started
		case "$?" in
			0)	log_end_msg 1;;
			*)	log_end_msg 0;;
		esac
	fi
	gbShowMessages=no
	gbUpdate=no

	# End info logs
	case "$sSwitch" in
		'full')	gfnMessage 'info' 'log' "Full update resolvers list - End";;
		*)		gfnMessage 'info' 'log' "Basic update resolvers list - End";;
	esac
}

# Download resolvers.csv from official source
gfnDownloadCsvFile() {
	local sCsvTemp sSigTemp sPubKeyTemp sType sMode sTitle nReturn nStep nTotalSteps sCsvUrl nToExecute bShowMessages

	nReturn=0
	nStep=0
	sTitle='Getting the resolver list		:'
	if [[ -z "$gsCplMinisignPass" ]]; then # Normal use
		nToExecute=1
		bShowMessages="$gbShowMessages"
		sCsvUrl="$gsCsvUrl"
		sCsvTemp="$gsCsvFile.tmp"
		sSigTemp="$gsSigFile.tmp"
		sPubKeyTemp="$gsPubKeyFile.tmp"

		sType='notice'
		sMode='log'
		nTotalSteps=11
	else # CSV compile use
		nToExecute=0
		bShowMessages=no
		sCsvUrl="$1"
		sCsvTemp="${gsCplTmpDir}/${gsCsvName}.tmp"
		sSigTemp="${gsCplTmpDir}/${gsSigName}.tmp"
		nTotalSteps=4
	fi

	# Step 1 - Remove old temp files
	(( nStep++ ))
	[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - Removes temp files)"
	[ -f $sCsvTemp ] && rm -f $sCsvTemp
	[ -f $sSigTemp ] && rm -f $sSigTemp
	gfnMessage 'notice' 'log' "Remove temp files"

	# Step 2 - HTTP Status: dnscrypt-resolvers.csv
	(( nStep++ ))
	[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - HTTP Status: '$gsCsvName')";
	gfnHttpStatus "$sCsvUrl" || nReturn=1

	# Step 3 - HTTP Status: dnscrypt-resolvers.csv.minisig
	if [[ ${nToExecute} -eq 1 ]]; then
		(( nStep++ ))
		[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - HTTP Status: '$gsSigName')"
		gfnHttpStatus "$gsSigUrl" || nReturn=1
	fi

	# Step 4 - HTTP Status: minisign.pub
	if [[ ${nToExecute} -eq 1 ]]; then
		(( nStep++ ))
		[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - HTTP Status: '$gsPubKeyName')"
		gfnHttpStatus "$gsPubKeyUrl" || nReturn=1
	fi

	if [ $nReturn -eq 0 ]; then
		# Step 5 - Download 'dnscrypt-resolvers.csv'
		(( nStep++ ))
		gfnMessage 'notice' 'log' "Download '$gsCsvName'"
		[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - Downloads: '$gsCsvName')"
		${binCURL} -o ${sCsvTemp} ${sCsvUrl} 2> /dev/null

		# Step 6 - Backup and update 'dnscrypt-resolvers.csv' in /usr/local/share/dnscrypt-proxy/
		(( nStep++ ))
		gfnMessage 'notice' 'log' "Move '$gsCsvName'"
		[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - Moves: '$gsCsvName')"
		if [ -e "$sCsvTemp" ] && [ -s "$sCsvTemp" ]; then
			if [[ ${nToExecute} -eq 1 ]]; then
				if [ -e "$gsCsvFile" ]; then
					mv -f $gsCsvFile $gsCsvFile.old
				fi
				dos2unix $sCsvTemp &> /dev/null
				mv -f $sCsvTemp $gsCsvFile
			fi
			gfnMessage 'info' 'log' "Successful download of the file '$gsCsvName'"
		else
			gfnMessage 'error' 'con' "Failed download of the file '$gsCsvName'"
			nReturn=1
		fi

		# Step 7 - Download 'dnscrypt-resolvers.csv.minisig'
		if [[ ${nToExecute} -eq 1 ]]; then
			(( nStep++ ))
			gfnMessage 'notice' 'log' "Download '$gsSigName'"
			[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - Downloads: '$gsSigName')"
			${binCURL} -o ${sSigTemp} ${gsSigUrl} 2> /dev/null
		fi

		# Step 8 - Backup and update 'dnscrypt-resolvers.csv.minisig' in /usr/local/share/dnscrypt-proxy/
		if [[ ${nToExecute} -eq 1 ]]; then
			(( nStep++ ))
			gfnMessage 'notice' 'log' "Move '$gsSigName'"
			[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - Moves: '$gsSigName')"
			if [ -e "$sSigTemp" ] && [ -s "$sSigTemp" ]; then
				if [ -e "$gsSigFile" ]; then
					mv -f $gsSigFile $gsSigFile.old
				fi
				mv -f $sSigTemp $gsSigFile
				gfnMessage 'info' 'log' "Successful download of the file '$gsSigName'"
			else
				gfnMessage 'error' 'con' "Failed download of the file '$gsSigName'"
				nReturn=1
			fi
		fi

		# Step 9 - Download 'minisign.pub'
		if [[ ${nToExecute} -eq 1 ]]; then
			(( nStep++ ))
			gfnMessage 'notice' 'log' "Download '$gsPubKeyName'"
			[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - Downloads: '$gsPubKeyName')"
			${binCURL} -o ${sPubKeyTemp} ${gsPubKeyUrl} 2> /dev/null
		fi

		# Step 10 - Backup and update 'minisign.pub' in /usr/local/share/dnscrypt-proxy/
		if [[ ${nToExecute} -eq 1 ]]; then
			(( nStep++ ))
			gfnMessage 'notice' 'log' "Move '$gsPubKeyName'"
			[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - Moves: '$gsPubKeyName')"
			if [ -e "$sPubKeyTemp" ] && [ -s "$sPubKeyTemp" ]; then
				if [ -e "$gsPubKeyFile" ]; then
					mv -f $gsPubKeyFile $gsPubKeyFile.old
				fi
				mv -f $sPubKeyTemp $gsPubKeyFile
				gfnMessage 'info' 'log' "Successful download of the file '$gsPubKeyName'"
			else
				gfnMessage 'error' 'con' "Failed download of the file '$gsPubKeyName'"
				nReturn=1
			fi
		fi

		if [ ${nReturn} -eq 0 ] && [ ${nToExecute} -eq 1 ]; then
			# Minisign check of 'dnscrypt-resolvers.csv'
			# Step 11
			(( nStep++ ))
			gfnMessage 'notice' 'log' "Checks '$gsCsvName'"
			[ "$bShowMessages" == yes ] && gfnProgressBar -s $nStep -e $nTotalSteps -t "$sTitle" -m "($nStep/$nTotalSteps - Checks: '$gsCsvName')"
			if gfnCheckCommand 0 minisign; then
				minisign -q -V -m "$gsCsvFile" -x "$gsSigFile" -p "$gsPubKeyFile"
				if [ $? -ne 0 ]; then
					sType='warning'
					sMode='con'
					gsMess="The '$gsCsvName' file has been changed or is corrupted.\n"
					gsMess+="Is strongly recommended download a new copy.\n"
					gsMess+="Your system may be leaking DNS queries.\n"
					gsMess+="Execute the following command: ${gsG}service $gsProxyName update${gsN}\n"
				else
					sType='info'
					gsMess="The '$gsCsvName' file is good."
				fi
			else
				sType='error'
				gsMess="Minisign is not installed !"
			fi

			gfnMessage "$sType" "$sMode" "$gsMess"
		fi

		# Return for CSV compile
		[ ${nToExecute} -eq 0 ] && return ${nReturn}
	fi
}

# Update resolvers list table
gfnUpdateDatabase() {
	local sListName sIfExist sValues sIpVersion nCount nHostResult nPingResult
	local sName sFullName sDescription sLocation sCoordinates sUrl sVersion sDnsSec sNoLogs sNameCoin sResolverAddress sProviderName sPubKey sPubKeyTxt
	local sFullNameOld sDescriptionOld sLocationOld sCoordinatesOld sUrlOld sVersionOld sDnsSecOld sNoLogsOld sNameCoinOld sResolverAddressOld sProviderNameOld sPubKeyOld sPubKeyTxtOld

	#------------------------------------------------------------
	# dnscrypt-resolvers.csv CSV format
	#------------------------------------------------------------
	# dnscrypt-resolvers.csv Columns
	# 1 Name
	# 2 Full name
	# 3 Description
	# 4 Location
	# 5 Coordinates
	# 6 URL
	# 7 Version
	# 8 DNSSEC validation
	# 9 No logs
	# 10 Namecoin
	# 11 Resolver address
	# 12 Provider name
	# 13 Provider public key
	# 14 Provider public key TXT record
	#------------------------------------------------------------

	if [ -f $gsCsvFile ]; then
		# Before, we will delete old resolver does not exist in the new CSV file
		gfnMessage 'notice' 'log' 'Cleaning of the database'
		nCount=0
		gnCountResolver="`cmdMySQL 'MySB_db' "SELECT count(name) FROM dnscrypt_resolvers;"`"
		sListName="`cmdMySQL 'MySB_db' "SELECT name FROM dnscrypt_resolvers;"`"
		if [ -n "$sListName" ]; then
			for sName in $sListName; do
				(( nCount++ ))
				[ "$gbShowMessages" == yes ] && gfnProgressBar -s $nCount -e $gnCountResolver -t 'Cleaning the database			:' -m "($nCount/$gnCountResolver	- $sName)"
				sIfExist="`cat $gsCsvFile | grep "$sName"`"
				if [ -z "$sIfExist" ]; then
					gfnMessage "info" "log" "Deleting from database: '$sName'"
					cmdMySQL 'MySB_db' "DELETE FROM dnscrypt_resolvers WHERE name='$sName';"
				fi
			done
		fi

		# Get resolvers information from 'dnscrypt-resolvers.csv'
		gfnMessage 'notice' 'log' 'Updating the database'
		nCount=0
		gnCountResolver="`csvtool -t ',' -u '|' cat $gsCsvFile | csvtool drop 1 - | wc -l`"
		sValues="`csvtool -t ',' -u '|' cat $gsCsvFile | csvtool drop 1 - | sed "s/'//g;" | sed 's/"//g;' | sed 's/ /#/g;'`"
		for sLine in $sValues; do
			sLine="`echo $sLine | sed 's/#/ /g;'`"
			sName="`echo $sLine | awk '{split($0,a,\"|\"); print a[1]}'`"
			sFullName="`echo $sLine | awk '{split($0,a,\"|\"); print a[2]}'`"
			sDescription="`echo $sLine | awk '{split($0,a,\"|\"); print a[3]}'`"
			sLocation="`echo $sLine | awk '{split($0,a,\"|\"); print a[4]}'`"
			sCoordinates="`echo $sLine | awk '{split($0,a,\"|\"); print a[5]}'`"
			sUrl="`echo $sLine | awk '{split($0,a,\"|\"); print a[6]}'`"
			sVersion="`echo $sLine | awk '{split($0,a,\"|\"); print a[7]}'`"
			sDnsSec="`echo $sLine | awk '{split($0,a,\"|\"); print a[8]}'`"
			sNoLogs="`echo $sLine | awk '{split($0,a,\"|\"); print a[9]}'`"
			sNameCoin="`echo $sLine | awk '{split($0,a,\"|\"); print a[10]}'`"
			sResolverAddress="`echo $sLine | awk '{split($0,a,\"|\"); print a[11]}'`"
			sProviderName="`echo $sLine | awk '{split($0,a,\"|\"); print a[12]}'`"
			sPubKey="`echo $sLine | awk '{split($0,a,\"|\"); print a[13]}'`"
			sPubKeyTxt="`echo $sLine | awk '{split($0,a,\"|\"); print a[14]}'`"
			case $sName in
				*ipv6*)	sIpVersion='ipv6';;
				*)		sIpVersion='ipv4';;
			esac

			# Add or update new informations in DB
			(( nCount++ ))
			[ "$gbShowMessages" == yes ] && gfnProgressBar -s $nCount -e $gnCountResolver -t 'Updating the database			:' -m "($nCount/$gnCountResolver	- $sName)"
			sIfExist="`cmdMySQL 'MySB_db' "SELECT full_name,description,location,coordinates,url,version,dnssec,no_logs,namecoin,resolver_address,provider_name,provider_public_key,provider_public_key_txt_record FROM dnscrypt_resolvers WHERE name='$sName';" | sed 's/\t/|/g;'`"
			sFullNameOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[1]}'`"
			sDescriptionOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[2]}'`"
			sLocationOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[3]}'`"
			sCoordinatesOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[4]}'`"
			sUrlOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[5]}'`"
			sVersionOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[6]}'`"
			sDnsSecOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[7]}'`"
			sNoLogsOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[8]}'`"
			sNameCoinOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[9]}'`"
			sResolverAddressOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[10]}'`"
			sProviderNameOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[11]}'`"
			sPubKeyOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[12]}'`"
			sPubKeyTxtOld="`echo $sIfExist | awk '{split($0,a,"|"); print a[13]}'`"

			# Check it
			# sIp="`echo $sResolverAddress | awk -F ':' '{print $1}'`"
			# host -4 -W2 ${sIp} &> /dev/null
			# nHostResult="$?"

			# ping -W2 -c1 ${sIp} &> /dev/null
			# nPingResult="$?"

			if [[ "$nHostResult" -eq 0 ]] || [[ "$nPingResult" -eq 0 ]]; then
				if [ -n "$sIfExist" ]; then
					if 	[ "$sFullNameOld" != "$sFullName" ] \
						|| [ "$sDescriptionOld" != "$sDescription" ] \
						|| [ "$sLocationOld" != "$sLocation" ] \
						|| [ "$sCoordinatesOld" != "$sCoordinates" ] \
						|| [ "$sUrlOld" != "$sUrl" ] \
						|| [ "$sVersionOld" != "$sVersion" ] \
						|| [ "$sDnsSecOld" != "$sDnsSec" ] \
						|| [ "$sNoLogsOld" != "$sNoLogs" ] \
						|| [ "$sNameCoinOld" != "$sNameCoin" ] \
						|| [ "$sResolverAddressOld" != "$sResolverAddress" ] \
						|| [ "$sProviderNameOld" != "$sProviderName" ] \
						|| [ "$sPubKeyOld" != "$sPubKey" ] \
						|| [ "$sPubKeyTxtOld" != "$sPubKeyTxt" ]; then

						gfnMessage "info" "log" "Resolver updated: '$sName'"
						cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET full_name='$sFullName', description='$sDescription', location='$sLocation', coordinates='$sCoordinates', url='$sUrl', version='$sVersion', dnssec='$sDnsSec', no_logs='$sNoLogs', namecoin='$sNameCoin', resolver_address='$sResolverAddress', provider_name='$sProviderName', provider_public_key='$sPubKey', provider_public_key_txt_record='$sPubKeyTxt', ip_version='$sIpVersion', certificate='0' WHERE name='$sName';"
					fi
				else
					gfnMessage "info" "log" "Resolver added: '$sName'"
					cmdMySQL 'MySB_db' "INSERT INTO dnscrypt_resolvers (full_name,description,location,coordinates,url,version,name,dnssec,no_logs,namecoin,resolver_address,provider_name,provider_public_key,provider_public_key_txt_record,ip_version) VALUES ('$sFullName','$sDescription','$sLocation','$sCoordinates','$sUrl','$sVersion','$sName','$sDnsSec','$sNoLogs','$sNameCoin','$sResolverAddress','$sProviderName','$sPubKey','$sPubKeyTxt','$sIpVersion');"
				fi
			fi
		done
	fi
}

# CSV files compile
gfnCompileCsvFiles() {
	local nCount nCountUrl nCountResolver nCountResolver nHostResult nPingResult nCertificate nDuplicate
	local sCsvUrl sLine sResolverAddress sPort sValues sPort sIp sCsvFile sMess sResult

	# Create needed directories
	log_daemon_msg "Prepare environment"
	[[ ! -d ${gsCplDestDir}/archives ]] && mkdir -p ${gsCplDestDir}/archives
	[[ ! -d ${gsCplDestDir}/logs ]] && mkdir -p ${gsCplDestDir}/logs
	[[ ! -d ${gsCplTmpDir} ]] && mkdir -p ${gsCplTmpDir}
	# Cleaning
	rm -f ${gsCplTmpDir}/*.csv
	rm -f ${gsCplDestDir}/*.*
	rm -f ${gsCplDestDir}/logs/*.*
	rm -f $$gsCplFinalCsv*
	# Count URLs
	nCountUrl=0
	for sCsvUrl in ${gsCsvUrl} ${gsCplAllCsvUrls} ${gsCplDeadResolversList}; do
		(( nCountUrl++ ))
	done
	# Creating new files
	echo "${gsCplFirstLine}" > ${gsCplTmpDir}/d_final.csv
	echo "${gsCplFirstLine}" > ${gsCplTmpDir}/c_sorted.csv
	gfnStatusLSB

	# Stop current dnscrypt
	log_daemon_msg "Stopping $gsProxyDesc in system"
	gfnStop
	gfnStatusLSB

	#### Download all CSV files into only only
	nCount=0
	echo "${gsCplMessage}<br /><br />Original 'dnscrypt-resolvers.csv' files:<br />" > ${gsCplDestDir}/release.md
	echo "--------------------" >> ${gsCplDestDir}/results.log
	for sCsvUrl in ${gsCsvUrl} ${gsCplAllCsvUrls} ${gsCplDeadResolversList}; do
		(( nCount++ ))
		gfnProgressBar -s ${nCount} -e ${nCountUrl} -t 'Download all CSV files		:' -m "(${nCount}/${nCountUrl})"

		gfnDownloadCsvFile "$sCsvUrl"
		if [[ ${?} -ne 0 ]]; then
			echo "BAD URL: ${sCsvUrl}" >> ${gsCplDestDir}/results.log
			continue
		else
			echo "GOOD URL: ${sCsvUrl}" >> ${gsCplDestDir}/results.log
		fi

		# release.md
		echo "$sCsvUrl <br />" >> ${gsCplDestDir}/release.md

		if [ -f ${gsCplTmpDir}/${gsCsvName}.tmp ]; then
			sed -i '/Name,/d' ${gsCplTmpDir}/${gsCsvName}.tmp
			sed -i '/-ipv6/d' ${gsCplTmpDir}/${gsCsvName}.tmp
			sed -i 's/, / /g;' ${gsCplTmpDir}/${gsCsvName}.tmp
			sed -i "s/'/ /g;" ${gsCplTmpDir}/${gsCsvName}.tmp
			sed -i 's/"//g;' ${gsCplTmpDir}/${gsCsvName}.tmp
			sed -i 's/ /#/g;' ${gsCplTmpDir}/${gsCsvName}.tmp
			cat ${gsCplTmpDir}/${gsCsvName}.tmp >> ${gsCplTmpDir}/a_downloaded.csv
		fi
	done
	echo "--------------------" >> ${gsCplDestDir}/results.log
	rm -f ${gsCplTmpDir}/${gsCsvName}.tmp

	#### Compile
	nCount=0
	nCountResolver=$(csvtool -t ',' -u '|' cat ${gsCplTmpDir}/a_downloaded.csv | wc -l)
	sValues=$(csvtool -t ',' -u '|' cat ${gsCplTmpDir}/a_downloaded.csv)
	for sLine in ${sValues}; do
		sName="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[1]}'`"
		sDnsSec="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[8]}'`"
		sNoLogs="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[9]}'`"
		sNameCoin="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[10]}'`"
		sResolverAddress="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[11]}'`"
		sProviderName="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[12]}'`"
		sPubKey="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[13]}'`"
		sPubKeyTxt="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[14]}'`"

		(( nCount++ ))
		gfnProgressBar -s ${nCount} -e ${nCountResolver} -t 'Compile the CSV file		:' -m "(${nCount}/${nCountResolver}	- ${sName})"

		sPort="$(echo ${sResolverAddress} | awk -F ':' '{print $2}')"
		[[ -z "${sPort}" ]] && sResolverAddress="$sResolverAddress:443"

		echo "${sName},,,,,,,${sDnsSec},${sNoLogs},${sNameCoin},${sResolverAddress},${sProviderName},${sPubKey},${sPubKeyTxt}" >> ${gsCplTmpDir}/b_compiled.csv
	done

	# Sort uniq
	sed -i 's/#/ /g;' ${gsCplTmpDir}/a_downloaded.csv
	sed -i 's/""//g;' ${gsCplTmpDir}/a_downloaded.csv
	sort -u ${gsCplTmpDir}/b_compiled.csv >> ${gsCplTmpDir}/c_sorted.csv

	#### Check resolvers
	nDuplicate=0
	nCount=0
	nCountResolver=$(csvtool -t ',' -u '|' cat ${gsCplTmpDir}/c_sorted.csv | csvtool drop 1 - | wc -l)
	sValues="$(csvtool -t ',' -u '|' cat ${gsCplTmpDir}/c_sorted.csv | csvtool drop 1 -)"
	for sLine in ${sValues}; do
		sName="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[1]}'`"
		sFullName="$(grep "${sName}," ${gsCplTmpDir}/a_downloaded.csv | awk -F ',' '{print $2}' | tail -1)"
		sDescription="$(grep "${sName}," ${gsCplTmpDir}/a_downloaded.csv | awk -F ',' '{print $3}' | tail -1)"
		sLocation="$(grep "${sName}," ${gsCplTmpDir}/a_downloaded.csv | awk -F ',' '{print $4}' | tail -1)"
		sCoordinates="$(grep "${sName}," ${gsCplTmpDir}/a_downloaded.csv | awk -F ',' '{print $5}' | tail -1)"
		sUrl="$(grep "${sName}," ${gsCplTmpDir}/a_downloaded.csv | awk -F ',' '{print $6}' | tail -1)"
		sVersion="$(grep "${sName}," ${gsCplTmpDir}/a_downloaded.csv | awk -F ',' '{print $7}' | tail -1)"
		sDnsSec="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[8]}'`"
		sNoLogs="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[9]}'`"
		sNameCoin="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[10]}'`"
		sResolverAddress="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[11]}'`"
		sIp=$(echo ${sResolverAddress} | awk -F ':' '{print $1}')
		sProviderName="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[12]}'`"
		sPubKey="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[13]}'`"
		sPubKeyTxt="`echo ${sLine} | awk '{split($0,a,\"|\"); print a[14]}'`"
		sCsvFile="${gsCplTmpDir}/d_dead.csv"

		echo  >> ${gsCplDestDir}/results.log
		echo "--------------------" >> ${gsCplDestDir}/results.log
		echo "Name: ${sName}" >> ${gsCplDestDir}/results.log
		echo "Full Name: ${sFullName}" >> ${gsCplDestDir}/results.log
		echo "Description: ${sDescription}" >> ${gsCplDestDir}/results.log
		echo "Location: ${sLocation}" >> ${gsCplDestDir}/results.log
		echo "Coordinates: ${sCoordinates}" >> ${gsCplDestDir}/results.log
		echo "URL: ${sUrl}" >> ${gsCplDestDir}/results.log
		echo "Version: ${sVersion}" >> ${gsCplDestDir}/results.log
		echo "DNS Sec: ${sDnsSec}" >> ${gsCplDestDir}/results.log
		echo "No Logs: ${sNoLogs}" >> ${gsCplDestDir}/results.log
		echo "NameCoin: ${sNameCoin}" >> ${gsCplDestDir}/results.log
		echo "ResolverAddress: ${sResolverAddress}" >> ${gsCplDestDir}/results.log
		echo "IP: ${sIp}" >> ${gsCplDestDir}/results.log
		echo "ProviderName: ${sProviderName}" >> ${gsCplDestDir}/results.log
		echo "PubKey: ${sPubKey}" >> ${gsCplDestDir}/results.log
		echo "PubKeyTxt: ${sPubKeyTxt}" >> ${gsCplDestDir}/results.log
		echo "--------------------" >> ${gsCplDestDir}/results.log

		(( nCount++ ))
		gfnProgressBar -s ${nCount} -e ${nCountResolver} -t 'Clean the CSV file		:' -m "(${nCount}/${nCountResolver}	- ${sName})"

		# Check duplicated resolvers
		echo "--> Duplicate result: $(grep "${sName}|" ${gsCplTmpDir}/c_sorted.csv | wc -l)" >> ${gsCplDestDir}/results.log
		[[ -f "${gsCplTmpDir}/d_final.csv" ]] && nDuplicate="$(grep "${sName}," ${gsCplTmpDir}/d_final.csv | wc -l)"

		# Host check
		host -4 -W2 ${sIp} &> /dev/null
		nHostResult="$?"
		[[ "$nHostResult" -ne 0 ]] && sResult="Failed" || sResult="Done"
		echo "--> Host result: $sResult" >> ${gsCplDestDir}/results.log

		# Ping check
		ping -W2 -c1 ${sIp} &> /dev/null
		nPingResult="$?"
		[[ "$nPingResult" -ne 0 ]] && sResult="Failed" || sResult="Done"
		echo "--> Ping result: $sResult" >> ${gsCplDestDir}/results.log

		# Certificate check
		eval "${gsProxyBin} -R ${sName} -t ${gnProxyTestMargin} -u ${gsDeamonUser} -L ${gsCplTmpDir}/c_sorted.csv -l ${gsCplDestDir}/logs/${sName}.log -m 7 >> ${gsCplDestDir}/logs/${sName}.log 2>&1"
		nCertificate=$?
		case "$nCertificate" in
			0) #  a valid certificate can be used
				sCsvFile="${gsCplTmpDir}/d_final.csv"; sMess="A valid certificate can be used"
			;;
			4) #  a valid certificate can be used
				sCsvFile="${gsCplTmpDir}/d_final.csv"; sMess="A currently valid certificate is going to expire before margin $gnProxyTestMargin"
			;;
			2)  sMess="No valid certificates can be used";;
			3)  sMess="A timeout occurred";;
			*)  sMess="An unknow error occurred: $nCertificate";;
		esac

		# Check if DNS Security Extensions are supported
		([[ "${sDnsSec}" == "yes" ]] && [[ -n "$(grep "does not support DNS Security Extensions" ${gsCplDestDir}/logs/${sName}.log)" ]]) && sDnsSec="no" && echo "--> DNS Sec value changed: YES to NO" >> ${gsCplDestDir}/results.log
		([[ "${sDnsSec}" == "no" ]] && [[ -n "$(grep "DNS Security Extensions are supported" ${gsCplDestDir}/logs/${sName}.log)" ]]) && sDnsSec="yes" && echo "--> DNS Sec value changed: NO to YES" >> ${gsCplDestDir}/results.log
		# Provider supposedly doesn't keep logs
		([[ "${sNoLogs}" == "yes" ]] && [[ -z "$(grep "Provider supposedly doesn't keep logs" ${gsCplDestDir}/logs/${sName}.log)" ]]) && sNoLogs="no" && echo "--> No Logs value changed: YES to NO" >> ${gsCplDestDir}/results.log
		([[ "${sNoLogs}" == "no" ]] && [[ -n "$(grep "Provider supposedly doesn't keep logs" ${gsCplDestDir}/logs/${sName}.log)" ]]) && sNoLogs="yes" && echo "--> No Logs value changed: NO to YES" >> ${gsCplDestDir}/results.log
		# Check if Namecoin domains can be resolved
		([[ "${sNameCoin}" == "yes" ]] && [[ -z "$(grep "Namecoin domains can be resolved" ${gsCplDestDir}/logs/${sName}.log)" ]]) && sNameCoin="no" && echo "--> NameCoin value changed: NO to YES" >> ${gsCplDestDir}/results.log
		([[ "${sNameCoin}" == "no" ]] && [[ -n "$(grep "Namecoin domains can be resolved" ${gsCplDestDir}/logs/${sName}.log)" ]]) && sNameCoin="yes" && echo "--> NameCoin value changed: YES to NO" >> ${gsCplDestDir}/results.log

		echo "--> Certificate validity result: $sMess" >> ${gsCplDestDir}/results.log
		if [ "$sCsvFile" == "${gsCplTmpDir}/d_final.csv" ]; then
			[[ "$nDuplicate" -eq 1 ]] && sCsvFile="${gsCplTmpDir}/d_duplicated.csv"
			echo "==> Resolver ADDED !" >> ${gsCplDestDir}/results.log
		else
			echo "==> Resolver REMOVED !" >> ${gsCplDestDir}/results.log
		fi

		echo "--------------------" >> ${gsCplDestDir}/results.log

		echo "${sName},\"${sFullName}\",\"${sDescription}\",\"${sLocation}\",\"${sCoordinates}\",${sUrl},${sVersion},${sDnsSec},${sNoLogs},${sNameCoin},${sResolverAddress},${sProviderName},${sPubKey},${sPubKeyTxt}" >> "$sCsvFile"
	done
	sed -i 's/\s\+$//' results.log
	sed -i 's/""//g;' ${gsCplTmpDir}/d_final.csv
	sort -u ${gsCplTmpDir}/d_dead.csv >> ${gsCplDestDir}/dead-resolvers.csv
	cp ${gsCplTmpDir}/d_final.csv ${gsCplFinalCsv}

	# Start current dnscrypt
	log_daemon_msg "Starting $gsProxyDesc in system"
	gfnStart
	gfnStatusLSB

	# Creating a key pair
	if [ ! -f "${gsCplMinisignPrivKey}" ] || [ ! -f "${gsCplMinisignPubKey}" ]; then
		echo -e "$gsCplMinisignPass\\n$gsCplMinisignPass" | minisign -G -p "${gsCplMinisignPubKey}" -s "${gsCplMinisignPrivKey}"
	fi

	# Signing CSV file
	if [ -f "${gsCplMinisignPubKey}" ] && [ -f "${gsCplMinisignPrivKey}" ]; then
		echo "$gsCplMinisignPass" | minisign -Sm "${gsCplFinalCsv}" -t "MySB - DNScrypt Resolvers List - ${gdCplDateFormated}-${gdCplTimeFormated}" -s "${gsCplMinisignPrivKey}"
	else
		echo "Signing '${gsCplFinalCsv}' failed !"
		exit 1
	fi

	# Verifying CSV file
	minisign -Vm ${gsCplFinalCsv} -p ${gsCplMinisignPubKey} -x ${gsCplFinalCsv}.minisig -c "$gsCplMessage" -t "$gsCplMessage"
	if [[ $? -ne 0 ]]; then
		echo "Minisign verification failed !"
		exit 1
	fi

	# Archives
	cp -f ${gsCplFinalCsv} ${gsCplDestDir}/archives/${gdCplDate}-${gdCplTime}.csv
	[ -f ${gsCplDestDir}/dead-resolvers.csv ] && cp -f ${gsCplDestDir}/dead-resolvers.csv ${gsCplDestDir}/archives/dead-resolvers.csv
}

# Function START
gfnStart() {
	local sPids nPid nRunning nCountProcess nCountResolver nResolverQty sType
	sPids=''
	nPid=''
	nRunning=0
	nCountResolver=0
	gnCertificate=0
	gbShowMessages=no

	# Blocks startup if disabled via the portal
	if [ $gbLockStart -eq 0 ]; then
		gfnMessage 'info' 'con' "$gsProxyDesc disabled via the portal !"
	else
		# Stop others processes
		sPids="`pidof $gsProxyName`"
		if [ -n "$sPids" ]; then
			nRunning="`echo $sPids | wc -w`"
			gfnMessage 'info' 'log' "$gsProxyDesc is already running, processes: $nRunning"
		else
			# Update clock
			/usr/sbin/ntpdate -u 0.pool.ntp.org 1.pool.ntp.org > /dev/null 2>&1

			# Get list of resolvers wished (gsResolversList)
			gfnCheckResolversWished

			# Force all resolvers to be inactive in DB
			cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET forwarder='', pid='';"

			if [ "$gbUpdate" == no ]; then
				nResolverQty=$gnNumberOfDaemon
			else
				nResolverQty=$gnCountResolver
			fi

			# Adapt PeerGuardian to authorize resolvers responses
			if [ "$gbIsInstalled_PeerGuardian" == "YES" ]; then
				# shellcheck source=/opt/MySB/inc/funcs_by_script/funcs_PeerGuardian
				[ -z "$funcs_PeerGuardian" ] && source $MySB_InstallDir/inc/funcs_by_script/funcs_PeerGuardian
				gfnPeerGuardianPglcmdConf 0
				gfnPeerGuardianIptablesInsert 0
				pglcmd restart &> /dev/null
			fi
			# Adapt BIND to use DNScrypt
			gfnSwitchDNS 'dnscrypt' $nResolverQty;

			for sResolver in $gsResolversList; do
				if [ $nRunning -ne $nResolverQty ]; then
					(( nCountResolver++ ))
					[ "$gbUpdate" == yes ] && gfnProgressBar -s $nCountResolver -e $gnCountResolver -t "Starting all resolvers			:" -m "($nCountResolver/$gnCountResolver	- $sResolver)"

					# Delete ghost screen pid file
					if [ -e $gsPidDir/$sResolver.pid ]; then
						pidofproc -p $gsPidDir/$sResolver.pid &> /dev/null || rm -f $gsPidDir/$sResolver.pid
					fi

					[ "$gbUpdate" == no ] && gfnCheckCertificateValidity "$sResolver"
					# Resolver certificate validity
					# 0: a valid certificate can be used, resolver will be used
					# 2: no valid certificates can be used, continue witout this sone
					# 3: a timeout  occurred, continue witout this sone
					# 4: a currently valid certificate is going to expire before margin, continue witout this sone
					if [ $gnCertificate -ne 0 ]; then
						sType='warning'
						case "$gnCertificate" in
							2)	gsMess="No valid certificates can be used";;
							3)	gsMess="A timeout occurred";;
							4)	gsMess="A currently valid certificate is going to expire before margin";;
							*)	sType='error'; gsMess="An unknow error occurred: $gnCertificate";;
						esac

						# Update DB
						cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET certificate='$gnCertificate', comments='$gsMess' WHERE name='$sResolver';"
					else
						let "nCountProcess=${nRunning}+1"

						$gsProxyName -R $sResolver -a 127.0.0.$nCountProcess:52 -p $gsPidDir/$sResolver.pid $gsProxyParams >> $gsLogFile 2>> $gsTmpDir/$sResolver.log
						sleep 0.2

						sPids="`pidof $gsProxyName`"
						if [ -n "$sPids" ]; then
							nPid=$(ps -p "$sPids" -o pid= -o user= -o args= | grep "127.0.0.$nCountProcess:52" | awk '{print $1 = substr($1, 1, 100)}')
						fi
						if [ -n "$nPid" ]; then
							# Start OK
							sType='info'
							gsMess="'$sResolver' is started completly"
							(( nRunning++ ))
							# Update DB
							cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET forwarder='127.0.0.$nCountProcess', pid='$nPid' WHERE name='$sResolver';"
						else
							# Start KO
							sType='error'
							gsMess="'$sResolver' did not started"
						fi
					fi

					gfnMessage "$sType" 'log' "$gsMess"
				fi
			done
		fi
	fi

	# Return
	# 0	: if daemon could not be started
	# 1+	: if daemon has been started
	if [ "$gbUpdate" == no ]; then
		case "$nRunning" in
			0)	gfnStop;;
			*)	gfnCheckDnsSpeed&;;
		esac
	fi

	# Restore boolean
	gbShowMessages=yes

	return $nRunning
}

# Function STOP the daemon/service
gfnStop() {
	local sType sPidList sPids sResolver nCount nCountResolvers

	sType='info'
	sPidList="`ls -1tr $gsPidDir/`"
	sPids=''
	nCount=0

	if [ -z "$sPidList" ]; then
		gsMess="$gsProxyDesc is not running !"
	else
		nCountResolvers="`echo $sPidList | wc -w`"
		for sPidFile in $sPidList; do
			(( nCount++ ))
			sResolver="`echo $sPidFile | sed 's/.pid//g;'`"
			[ "$gbUpdate" == yes ] && gfnProgressBar -s $nCount -e $nCountResolvers -t "Stopping processes			:" -m "($nCount/$nCountResolvers	- $sResolver)"
			start-stop-daemon --stop --quiet --oknodo --pidfile $gsPidDir/$sPidFile >> $gsLogFile 2>> $gsLogFile
		done
	fi

	# Ghost processes ?
	sPids="`pidof $gsProxyName`"
	if [ -n "$sPids" ]; then
		pkill -f $gsProxyName >> $gsLogFile
		sType='notice'
		gsMess="\nForce kill for ghost processes !"
	fi

	# Log file
	gfnMessage "$sType" 'log' "$gsMess"
	# Update DB
	cmdMySQL 'MySB_db' "UPDATE dnscrypt_resolvers SET forwarder='', pid='';"
	# Switch DNS
	gfnSwitchDNS 'bind'
}

# Variables stored in database
gfnVariableFormat() {
	local sConfigValues sIpVersion nNumberOfDaemon bOnlyNoLogs bOnlyDNSSec bOnlyNameCoin bRandom nResolversDb

	# Add resolvers to database
	nResolversDb="`cmdMySQL 'MySB_db' "SELECT count(name) FROM dnscrypt_resolvers;"`"
	if [ $nResolversDb -eq 0 ] && [ -z "`echo "$@" | grep 'update'`" ] && [ -z "`echo "$@" | grep 'full-update'`" ]; then
		gsMess="\n"
		gsMess+="${gsR}No DNS resolver found !${gsN}\n"
		gsMess+="Try to update resolvers list with the following command:\n"
		gsMess+="		${gsG}service $gsProxyName full-update${gsN}\n"
		gfnMessage 'ERROR' 'con' "$gsMess"
		exit 1
	fi

	# Get config from database
	sConfigValues="`cmdMySQL 'MySB_db' "SELECT ip_version,processes_qty,no_logs,dnssec,namecoin,random FROM dnscrypt_config WHERE id_dnscrypt_config='1';" | sed 's/\t/|/g;'`"
	sIpVersion="`echo $sConfigValues | awk '{split($0,a,"|"); print a[1]}'`"
	nNumberOfDaemon="`echo $sConfigValues | awk '{split($0,a,"|"); print a[2]}'`"
	bOnlyNoLogs="`echo $sConfigValues | awk '{split($0,a,"|"); print a[3]}'`"
	bOnlyDNSSec="`echo $sConfigValues | awk '{split($0,a,"|"); print a[4]}'`"
	bOnlyNameCoin="`echo $sConfigValues | awk '{split($0,a,"|"); print a[5]}'`"
	bRandom="`echo $sConfigValues | awk '{split($0,a,"|"); print a[6]}'`"

	# Ip Version
	case $sIpVersion in
		'ipv4'|'ipv6'|'all') gsIpVersion="$sIpVersion";;
	esac
	case $gsIpVersion in
		'ipv4')	gsDigProto='-4';;
		'ipv6')	gsDigProto='-6';;
	esac
	# Number of wanted daemons
	if [ $nNumberOfDaemon -ge 1 ] && [ $nNumberOfDaemon -le 6 ]; then
		gnNumberOfDaemon=$nNumberOfDaemon
	fi
	# No Logs
	case $bOnlyNoLogs in
		'yes'|'no') gbOnlyNoLogs="$bOnlyNoLogs";;
	esac
	# -E, --ephemeral-keys,  Not enabled by default because it may be slow, especially on non-Intel CPUs.
	# We activate it only if the remote server is logging activity.
	if [ "$gbOnlyNoLogs" == no ] && [ -z "`echo $gsProxyParams | grep '\-E'`" ]; then
		gsProxyParams="$gsProxyParams -E"
	fi
	# DNSsec
	case $bOnlyDNSSec in
		'yes'|'no') gbOnlyDNSSec="$bOnlyDNSSec";;
	esac
	# NameCoin
	case $bOnlyNameCoin in
		'yes'|'no') gbOnlyNameCoin="$bOnlyNameCoin";;
	esac
	# Random resolvers
	case $bRandom in
		'yes'|'no') gbRandomResolvers="$bRandom";;
	esac

	# Variable format
	gbOnlyNoLogs="`echo $gbOnlyNoLogs | tr '[:upper:]' '[:lower:]'`"
	gbOnlyDNSSec="`echo $gbOnlyDNSSec | tr '[:upper:]' '[:lower:]'`"
	gbOnlyNameCoin="`echo $gbOnlyNameCoin | tr '[:upper:]' '[:lower:]'`"
	gbRandomResolvers="`echo $gbRandomResolvers | tr '[:upper:]' '[:lower:]'`"
	gsResolversList=''
	gnCountResolver=0
	gbUpdate=no
	gsMess=''
}

# Save configuration in interactive mode
gfnSaveConfig() {
	local nNumberOfDaemon nCountResolver sSearchByIpVersion

	case $gsIpVersion in
		'all')	sSearchByIpVersion="";;
		*)		sSearchByIpVersion=" AND ip_version='$gsIpVersion'";;
	esac

	nCountResolver="`cmdMySQL 'MySB_db' "SELECT count(name) FROM dnscrypt_resolvers WHERE dnssec='$gbOnlyDNSSec' AND no_logs='$gbOnlyNoLogs' AND namecoin='$gbOnlyNameCoin' $sSearchByIpVersion;"`"
	if [ $nCountResolver -lt $gnNumberOfDaemon ]; then
		nNumberOfDaemon=$nCountResolver
	elif [ $nCountResolver -eq 0 ]; then
		gbOnlyNameCoin=no
		nCountResolver="`cmdMySQL 'MySB_db' "SELECT count(name) FROM dnscrypt_resolvers WHERE dnssec='$gbOnlyDNSSec' AND no_logs='$gbOnlyNoLogs' AND namecoin='$gbOnlyNameCoin' $sSearchByIpVersion;"`"
	else
		nNumberOfDaemon=$gnNumberOfDaemon
	fi
	cmdMySQL 'MySB_db' "UPDATE dnscrypt_config SET processes_qty='$nNumberOfDaemon', no_logs='$gbOnlyNoLogs', dnssec='$gbOnlyDNSSec', namecoin='$gbOnlyNameCoin', random='$gbRandomResolvers' WHERE id_dnscrypt_config='1';"

	if [ -z "$1" ]; then
		gsMess="Configuration saved:\n\n"
		gsMess+="  Process qty		  : $nNumberOfDaemon\n"
		gsMess+="  IP version		   : $gsIpVersion\n"
		gsMess+="  Random			   : $gbRandomResolvers\n"
		gsMess+="  No Logs			  : $gbOnlyNoLogs\n"
		gsMess+="  DNSSec			   : $gbOnlyDNSSec\n"
		gsMess+="  NameCoin			 : $gbOnlyNameCoin\n"
		gsMess+="  Available resolvers  : $nCountResolver\n\n"
		gfnMessage 'info' 'con' "$gsMess"
	fi
}

# Basic cURL connection test filtering "HTTP/1.1" pattern to extract http status
# HTTP/1.1 200 OK
# HTTP/1.1 301 Moved Permanently (if file not found)
# and none if internet or DNS fail
gfnHttpStatus() {
	local sUrl sStatus sType nReturn

	sUrl="$1"
	sType='notice'
	nReturn=0

	case "$($binCURL --no-buffer --head $sUrl)" in
		*"200 OK"*)				  sStatus="200";;
		*"404 Not Found"*)		   sStatus="404";;
		*"301 Moved Permanently"*)   sStatus="301";;
		*""*)						sStatus="?";;
	esac
	if [ "$sStatus" == "301" ] || [ "$sStatus" == "404" ] || [ "$sStatus" == "?" ]; then
		gsMess="\nRemote file '$sUrl' not found.\n\n"
		gsMess+="Please verify internet connection and URL.\n"
		gsMess+="HTTP Error: ${sStatus}"

		sType='error'
		nReturn=1
	else
		gsMess="HTTP Status: ${sStatus} for $sUrl"
	fi

	gfnMessage "$sType" 'log' "$gsMess"
	return $nReturn
}

# Progress Bar - https://github.com/fearside/ProgressBar/
gfnProgressBar() {
	local sTitle sMessage sLine nStart nEnd nWidth nProgress nDone nLeft nPrevious

	nStart=0
	nEnd=100
	sTitle='Progress :'
	sMessage=''
	nWidth=40

	# Get the options.
	OPTS=`getopt --shell bash --options s:e:t:m:w: --name "Progress bar" -- "$@"`
	if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
	eval set -- "$OPTS"
	while true; do
		case "$1" in
			-s) nStart="$2"; shift 2;;		# Sets the minimal progress value (default 0)
			-e) nEnd="$2"; shift 2;;		# Sets the maximal progress value (default 100)
			-t) sTitle="$2"; shift 2;;		# Sets the title
			-m) sMessage="$2"; shift 2;;	# Sets a message at the end of line
			-w) nWidth="$2"; shift 2;;		# Sets the width of the progress-bar (default 40)
			--)	shift; break;;
		esac
	done
	if [ $# -ne 0 ]; then
		echo "Unknown arguments: $*" 1>&2
		exit 1
	fi

	# Process data
	let "nProgress=(${nStart}*100/${nEnd}*100)/100"
	let "nDone=(${nProgress}*4)/10"
	let "nLeft=${nWidth}-${nDone}"
	# Build progressbar string lengths
	nDone=$(printf "%${nDone}s")
	nLeft=$(printf "%${nLeft}s")

	# To clean end line if a dynamic message is given
	if [ -n "$sMessage" ]; then
		nPrevious=${gnLenght}
		[ -z $nPrevious ] && nPrevious=$(echo "$sMessage" | wc -m)
		gnLenght=$(echo "$sMessage" | wc -m)
		sMessage=$(echo $sMessage | awk '{printf("%-'$nPrevious's", $0) }')
	fi

	# Build progressbar strings and print the ProgressBar line
	sLine=$(printf "\r$sTitle [${nDone// /#}${nLeft// /-}] ${nProgress}%% ${sMessage}")
	echo -en "${sLine}\r"

	# New line at the end
	if [ $nProgress -eq 100 ]; then
		echo
	fi
}

# Show Messages
gfnMessage() {
	local sType sMode sMess

	# Options:
	# $1:	[notice|info|warning|error]
	# 		notice - send message to log [NOTICE]
	# 		info - send message to log [INFO]
	#		warning - send message to log [WARNING]
	#		error - send message to log [ERROR]
	# $2:	[con|log]
	# 		con - send message to whiptail box OR console
	# 		log - send message only into log
	# $3:	[message]
	sType="$1"
	sMode="$2"
	sMess="$3"

	fnWriteToLogFile() {
		local sType sLineStart SaveLang LANG sMess

		sType="`echo $1 | tr '[:lower:]' '[:upper:]'`"
		sLineStart=''
		SaveLang=$LANG
		LANG=en_us_8859_1
		sMess="$2"

		case "$1" in
			'error')	sType="$sType";;
			'warning')	sType="$sType";;
			'notice')	sType="$sType";;
			'info')		sType="$sType";;
		esac

		sLineStart="`/bin/date '+%a %b %d %T %Y'` [$sType]";
		while IFS=$'\n' read -ra sLogLine; do
			for sLine in "${sLogLine[@]}"; do
				echo -e "$sLineStart $sLine" >> $gsLogFile
			done
		done <<< "$sMess"
		LANG=$SaveLang
	}

	case "$sMode" in
		'con')
			if [ "$gbCommandLine" == no ] && [ "$gbShowMessages" == yes ]; then
				$gsGUI --title "`echo $sType | tr '[:lower:]' '[:upper:]'`" --msgbox "$sMess"  0 0
			else
				printf "$sMess"
			fi
			fnWriteToLogFile "$sType" "$sMess"
		;;
		'log')
			fnWriteToLogFile "$sType" "$sMess"
		;;
	esac
}

# To execute when this script will exited whith integer (ex: exit 0, exit 1, ...)
gfnSigInt() {
	echo " Exiting... "
	exit 1
}

#------------------------------------------------------------
# START GRAPHIC MODE
#------------------------------------------------------------
gfnMenuShowConfig() {
	local sDescription sSelect

	while :
	do
		SelectedTask=$($gsGUI --title "$gsProxyDesc tasks" --menu "Choose your option" 22 70 15 \
		"1"  "Sets resolver filter (No Logs, DNSSec, NameCoin)"\
		"2"  "Sets number of resolver to use"\
		"3"  "Sort the resolvers randomly ?"\
		" "  ""\
		"4"  "Update the list of resolvers from the official source ?"\
		" "  ""\
		"5"  "Check resolver's certificate validity ?"\
		"6"  "Performs a speed test for started resolvers ?"\
		" "  ""\
		"7"  "Start/Restart $gsProxyDesc"\
		"8"  "$gsProxyDesc status"\
		"9"  "Stop $gsProxyDesc"\
		" "  ""\
		"10" "Quit"  3>&1 1>&2 2>&3)

		if [ $? -ne 0 ]; then
			return 1
		fi

		case $SelectedTask in
			# 1)	# Sets IP Version Filter
				# gfnMenuShowIpVersion
				# if [ $? -ne 0 ]; then
					# continue
				# fi
			# ;;
			1)	gfnMenuShowFilters;;
			2)	gfnMenuShowProcessQty;;
			3)	gfnMenuShowRandomly;;
			4)
				sDescription="What type of update do you want to perform ?\n\n"
				sDescription+="Basic update: Download and check '$gsCsvName' file.\n"
				sDescription+="Full update : Basic update + check certificate validity and do a speed test.\n\n"
				sDescription+="NOTE: A full update may take several minutes to complete."
				sSelect=$($gsGUI --title "Update resolvers list" \
						--menu "$sDescription" 15 80 2 \
						"1" "Basic update" \
						"2" "Full update" \
						3>&1 1>&2 2>&3)

				if [ $? = 0 ]; then
					case "$sSelect" in
						1)	gfnUpdateResolvers;;
						2)
							$gsGUI --title "Full resolvers update" --yesno "Perform a full update now ?" 0 0
							if [ $? -eq 0 ]; then
								gfnUpdateResolvers 'full'
							fi
						;;
					esac
				fi
			;;
			5)
				$gsGUI --title "Check certificates" --yesno "Check resolver's certificate validity ?" 0 0
				if [ $? -eq 0 ]; then
					gfnCheckResolversWished
					gfnStop
					gfnCheckCertificateValidity
				fi
			;;
			6)
				sDescription="Performs a speed test for started resolvers ?\n\n"
				sDescription+="NOTE: A speed test is performed every time $gsProxyDesc starts (for started resolvers).\n"
				sDescription+="NOTE: A speed test is performed during a full update (for filtered resolvers)."
				$gsGUI --title "Resolvers Speed Test" --yesno "$sDescription" 0 0
				if [ $? -eq 0 ]; then
					gfnCheckResolversWished
					gfnCheckDnsSpeed
				fi
			;;
			7)
				$gsGUI --title "$gsProxyDesc" --yesno "Are you sure you want to start $gsProxyDesc ?" 0 0
				if [ $? -eq 0 ]; then
					gfnStop
					gfnStart
					gfnGetStatusDetails
				fi
			;;
			8)	gfnGetStatusDetails;;
			9)
				$gsGUI --title "$gsProxyDesc" --yesno "Are you sure you want to stop $gsProxyDesc?" 0 0
				if [ $? -eq 0 ]; then
					gfnStop
				fi
			;;
			10)		clear; exit 0;;
			" ")	continue;;
			*)		clear; exit;;
		esac
	done
}

# Sets number of resolver to use
gfnMenuShowProcessQty() {
	local nNumberOfDaemon nOne nTwo nThree nFour nFive nSix

	case "$gnNumberOfDaemon" in
		1)	nOne=ON; nTwo=OFF; nThree=OFF; nFour=OFF; nFive=OFF; nSix=OFF;;
		2)	nOne=OFF; nTwo=ON; nThree=OFF; nFour=OFF; nFive=OFF; nSix=OFF;;
		3)	nOne=OFF; nTwo=OFF; nThree=ON; nFour=OFF; nFive=OFF; nSix=OFF;;
		4)	nOne=OFF; nTwo=OFF; nThree=OFF; nFour=ON; nFive=OFF; nSix=OFF;;
		5)	nOne=OFF; nTwo=OFF; nThree=OFF; nFour=OFF; nFive=ON; nSix=OFF;;
		6)	nOne=OFF; nTwo=OFF; nThree=OFF; nFour=OFF; nFive=OFF; nSix=ON;;
	esac

	nNumberOfDaemon=$($gsGUI --title "Sets number of resolver to use" \
					--radiolist "\nHow many resolver would you like to use ?\nDefault: 2" 15 50 6 \
					--noitem \
					"1" $nOne\
					"2" $nTwo\
					"3" $nThree\
					"4" $nFour\
					"5" $nFive\
					"6" $nSix \
					3>&1 1>&2 2>&3)

	if [ $? -eq 0 ]; then
		gnNumberOfDaemon=$nNumberOfDaemon

		# Update DB
		gfnSaveConfig

		return 0
	else
		return 1
	fi
}

# Sort the resolvers randomly ?
gfnMenuShowRandomly() {
	local bRandomResolvers sYes sNo

	case "$gbRandomResolvers" in
		'yes')	sYes=ON; sNo=OFF;;
		'no')	sYes=OFF; sNo=ON;;
	esac

	bRandomResolvers=$($gsGUI --title "Sort the resolvers randomly" \
					--radiolist "\nSort the resolvers randomly ?\n\nNOTE: The resolvers are sorted by speed each time." 10 60 2 \
					"yes" "Sort by speed and randomly" $sYes\
					"no" "Sort only by speed" $sNo\
					3>&1 1>&2 2>&3)

	if [ $? -eq 0 ]; then
		gbRandomResolvers=$bRandomResolvers

		# Update DB
		gfnSaveConfig

		return 0
	else
		return 1
	fi
}

# IP Version user filter
gfnMenuShowIpVersion() {
	local sIpVersion sAll sIPv4 sIPv6

	case "$gsIpVersion" in
		'all')	sAll=ON; sIPv4=OFF; sIPv6=OFF;;
		'ipv4')	sAll=OFF; sIPv4=ON; sIPv6=OFF;;
		'ipv6')	sAll=OFF; sIPv4=OFF; sIPv6=ON;;
	esac

	sIpVersion=$($gsGUI --title "IP Version Filter" \
				--radiolist "Filter resolvers by IP format" 10 50 3 \
				"ipv4" "Show only IPv4 resolvers" $sIPv4 \
				"ipv6" "Show only IPv6 resolvers" $sIPv6 \
				"all"  "Show IPv4 and IPv6 resolvers" $sAll \
				3>&1 1>&2 2>&3)

	if [ $? -eq 0 ]; then
		gsIpVersion="$sIpVersion"

		# Update DB
		gfnSaveConfig

		return 0
	else
		return 1
	fi
}

# Secure resolver filter
gfnMenuShowFilters() {
	local sValue

	sValue=$($gsGUI --title "Resolvers filters" --checklist \
	"Choose the filters to apply to the resolvers list." 10 90 3 \
	"NoLogs" "Check to hide the resolvers that store logs." $gbOnlyNoLogs \
	"DNSSec" "Check to show the resolvers that accept the DNSSec protocol." $gbOnlyDNSSec \
	"NameCoin" "Check to show the resolvers that accept the NameCoin protocol." $gbOnlyNameCoin 3>&1 1>&2 2>&3)

	if [ $? -eq 0 ]; then
		if [ "`echo $sValue | grep 'NoLogs'`" ]; then
			gbOnlyNoLogs=yes
		else
			gbOnlyNoLogs=no
		fi
		if [ "`echo $sValue | grep 'DNSSec'`" ]; then
			gbOnlyDNSSec=yes
		else
			gbOnlyDNSSec=no
		fi
		if [ "`echo $sValue | grep 'NameCoin'`" ]; then
			gbOnlyNameCoin=yes
		else
			gbOnlyNameCoin=no
		fi

		# Update DB
		gfnSaveConfig

		return 0
	else
		return 1
	fi
}

# Usage congig
gfnCmdShowUsageConfig() {
	local sUsage_Config

	sUsage_Config="  ${gsG}config${gsN}		  Without option, start $gsProxyDesc configuration in interative mode (service $gsProxyName config).\n"
	sUsage_Config+="				  With option(s), start $gsProxyDesc configuration in command line (service $gsProxyName config [options]).\n"
	sUsage_Config+="				  ${gsY}Options format example:${gsN}\n"
	sUsage_Config+="					service $gsProxyName config --nologs=no --proc=4\n"
	sUsage_Config+="				  ${gsY}Available options:${gsN}\n"
	# sUsage_Config+="					${gsG}--ipv${gsN}	 Sets filter to use addressing ipv4, ipv6 or both.\n"
	# sUsage_Config+="								  Without argument, matches to the default value.\n"
	# sUsage_Config+="								  Values  : [ipv4|ipv6|all]\n"
	# sUsage_Config+="								  Default : ipv4\n"
	sUsage_Config+="				   ${gsG}--nologs${gsN}   Sets filter to include resolvers who store dns query logs.\n"
	sUsage_Config+="								  Without argument, matches to the default value.\n"
	sUsage_Config+="								  Values  : [yes|no] (yes = Privacy, no = No privacy)\n"
	sUsage_Config+="								  Default : yes\n"
	sUsage_Config+="				   ${gsG}--dnssec${gsN}   Sets filter to include resolvers who accept or not DNSSec protocol.\n"
	sUsage_Config+="								  Without argument, matches to the default value.\n"
	sUsage_Config+="								  Values  : [yes|no] (yes = With DNSSec, no = Without DNSSec)\n"
	sUsage_Config+="								  Default : yes\n"
	sUsage_Config+="				   ${gsG}--namecoin${gsN} Sets filter to include resolvers who accept or not NameCoin protocol.\n"
	sUsage_Config+="								  Without argument, matches to the default value.\n"
	sUsage_Config+="								  Values  : [yes|no] (yes = With NameCoin, no = Without NameCoin)\n"
	sUsage_Config+="								  Default : yes\n"
	sUsage_Config+="				   ${gsG}--random${gsN}   Sets randomly filter for resolvers list.\n"
	sUsage_Config+="								  Without argument, matches to the default value.\n"
	sUsage_Config+="								  Values  : [yes|no] (yes = random, no = no random)\n"
	sUsage_Config+="								  Default : yes\n"
	sUsage_Config+="				   ${gsG}--proc${gsN}	 Sets the number of DNScrypt processes to run.\n"
	sUsage_Config+="								  Without argument, matches to the default value.\n"
	sUsage_Config+="								  Values  : [1-6]\n"
	sUsage_Config+="								  Default : 2\n"

	printf "$sUsage_Config"
}

# Usage global
gfnCmdShowUsage() {
	local sUsage

	sUsage="\n"
	sUsage+="${gsY}Usage:${gsN} service $gsProxyName {stop|status|status-details|config|update|full-update|speed-test}\n"
	sUsage+="${gsY}Usage:${gsN} service $gsProxyName {start|restart} [options]\n"
	sUsage+="\n"
	sUsage+="  ${gsG}start${gsN}		   Load $gsProxyDesc using a resolver previously selected by user on interactive mode (config) OR randomly choosed.\n"
	sUsage+="  ${gsG}stop${gsN}			Stop all $gsProxyDesc processes.\n"
	sUsage+="  ${gsG}restart${gsN}		 Stop all $gsProxyDesc processes, then load $gsProxyDesc using a resolver previously selected by user on interactive mode (config) OR randomly choosed.\n"
	sUsage+="  ${gsG}status${gsN}		  Show a quick status of resolvers started.\n"
	sUsage+="  ${gsG}status-details${gsN}  Show a full status of resolvers started.\n"
	sUsage+="  ${gsG}update${gsN}		  1/ Download the '$gsCsvName' file from official source;\n"
	sUsage+="				  2/ Performs signature check with Minisig (if available);\n"
	sUsage+="				  3/ Update resolvers informations stored in database;\n"
	sUsage+="  ${gsG}full-update${gsN}	 1/ Download the '$gsCsvName' file from official source;\n"
	sUsage+="				  2/ Performs signature check with Minisig (if available);\n"
	sUsage+="				  3/ Update resolvers informations stored in database;\n"
	sUsage+="				  4/ Performs a certificate validity for all resolvers;\n"
	sUsage+="					 ${gsU}NOTE${gsN}: If a resolver's certificate is not OK, it will be disabled in database for block to use it later.\n"
	sUsage+="				  5/ Performs a speed test for all resolvers filtered.\n"
	sUsage+="					 ${gsU}NOTE${gsN}: The time will be stored in the database to sort the resolvers in order of speed.\n"
	sUsage+="				  ${gsU}NOTE${gsN}: The full update process can make a moment for done completly.\n"
	#sUsage+="  ${gsG}dns-leak${gsN}		Performs a DNS Leak test (beta).\n"
	sUsage+="  ${gsG}speed-test${gsN}	  Performs a speed test for started resolvers.\n"
	sUsage+="  ${gsG}cron-check${gsN}	  Checks whether the DNScrypt process is operational and functional.\n"
	sUsage+="  ${gsG}help${gsN}			Show this help.\n"
	sUsage+="\n"

	printf "$sUsage"
	gfnCmdShowUsageConfig
}

#------------------------------------------------------------
# Functions - End
#------------------------------------------------------------

######################################################################
#
# E N D   W O R K S P A C E
#
######################################################################

######################################################################
#
# S T A R T   C O M M A N D   L I N E   M O D E
#
######################################################################

# DNScrypt-proyx global paramters
gsProxyParams="-d -u ${gsDeamonUser} -n 250 -m 6 -L $gsCsvFile -l $gsLogFile"
gnProxyTestMargin=720 # In minutes: 720 min = 12 hours = 0.5 days

# Bin CURL
binCURL="curl -skLS --retry 3"

# Colors - http://misc.flogisoft.com/bash/tip_colors_and_formatting
gsN="\e[0m"			# normal
gsU="\e[4m"			# underline
# gsB="\e[34m"		# blue
# gsBl="\e[94m"		# blue light
gsY="\e[33m"		# yellow
#gsYl="\e[93m"		# yellow light
gsG="\e[32m"		# green
#gsGl="\e[92m"		# green light
gsR="\e[31m"		# red
#gsRl="\e[91m"		# red light

# Default: we are in command line mode
gbCommandLine=yes

# Default: we display all message & progress bar
gbShowMessages=yes

# Default: it's not a resolvers update
gbUpdate=no

# Start some functions
gfnCheckPrerequisites
gfnCheckDirAndFiles
gfnVariableFormat "$@"

# Options
if [ $# -ge 1 ]; then
	for Arg in "$@"; do
		case "$Arg" in
			'start')
				log_daemon_msg "Starting $gsProxyDesc" "$gsProxyName"
				gfnStart
				# Return
				# 0	: if daemon could not be started
				# 1+	: if daemon has been started
				case "$?" in
					0)		log_end_msg 1;;
					[1-9]*)	log_end_msg 0;;
				esac
			;;
			'stop')
				log_daemon_msg "Stopping $gsProxyDesc" "$gsProxyName"
				gfnStop
				log_end_msg 0
			;;
			'restart')
				log_daemon_msg "Restarting $gsProxyDesc" "$gsProxyName"
				gfnStop
				gfnStart
				# Return
				# 0	: if daemon could not be started
				# 1+	: if daemon has been started
				case "$?" in
					0)		log_end_msg 1;;
					[1-9]*)	log_end_msg 0;;
				esac
			;;
			'status'|'status-details')
				case "$Arg" in
					status)
						sPidFiles="`ls -1r $gsPidDir/`"
						if [ -n "$sPidFiles" ]; then
							for sFile in $sPidFiles; do
								status_of_proc -p "$gsPidDir/$sFile" "$gsProxyName" "`echo $sFile | sed 's/.pid//g;'`" && log_end_msg
							done
						else
							gfnMessage 'notice' 'con' "$gsProxyDesc is not running !"
						fi
					;;
					status-details)
						gfnGetStatusDetails
					;;
				esac
			;;
			'update'|'full-update')
				case "$Arg" in
					'update')		gfnUpdateResolvers;;
					'full-update')	gfnUpdateResolvers 'full';;
				esac
			;;
			'speed-test')
				gfnCheckResolversWished
				gfnCheckDnsSpeed
			;;
			'cron-check')
				gfnCheckFromCron
			;;
			'csv-compile')
				gsCplMinisignPass=""
				trap gfnSigInt INT
				OPTS=$(getopt --shell bash -l password:: -n "$gsProxyDesc CSV compile" -- "$@")
				if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
				eval set -- "$OPTS"
				while true; do
					case "$1" in
						--password)
							case "$2" in
								'') gfnCmdShowUsageConfig; shift 2;;
								*)  gsCplMinisignPass="$2"; gfnCompileCsvFiles; shift; exit 1;;
							esac
						;;
						*)  break;;
					esac
				done
			;;
			# 'dns-leak')
				# gfnCheckDnsLeak
			# ;;
			'config')
				trap gfnSigInt INT
				gbUpdateDb=no
				OPTS=$(getopt --shell bash -l proc::,ipv::,dnssec::,nologs::,namecoin::,random:: -n "$gsProxyDesc configuration" -- "$@")
				if [ $? != 0 ] ; then echo "Terminating..." >&2 ; exit 1 ; fi
				eval set -- "$OPTS"
				while true; do
					case "$1" in
						--proc)
							case "$2" in
								[1-6])					gbUpdateDb=yes; gnNumberOfDaemon="$2"; shift 2;;
								'')						gbUpdateDb=yes; gnNumberOfDaemon=2; shift 2;;
								[7-9]*)					gfnCmdShowUsageConfig; shift; exit 1;;
							esac
						;;
						# --ipv)
							# case "$2" in
								# 'ipv4'|'ipv6'|'all')		gbUpdateDb=yes; gsIpVersion="$2"; shift 2;;
								# '')					gbUpdateDb=yes; gsIpVersion=ipv4; shift 2;;
								# *)						gfnCmdShowUsageConfig; shift; exit 1;;
							# esac
						# ;;
						--dnssec)
							case "$2" in
								'yes'|'no')				gbUpdateDb=yes; gbOnlyDNSSec="$2"; shift 2;;
								'')						gbUpdateDb=yes; gbOnlyDNSSec=yes; shift 2;;
								*)						gfnCmdShowUsageConfig; shift; exit 1;;
							esac
						;;
						--nologs)
							case "$2" in
								'yes'|'no')				gbUpdateDb=yes; gbOnlyNoLogs="$2"; shift 2;;
								'')						gbUpdateDb=yes; gbOnlyNoLogs=yes; shift 2;;
								*)						gfnCmdShowUsageConfig; shift; exit 1;;
							esac
						;;
						--namecoin)
							case "$2" in
								'yes'|'no')				gbUpdateDb=yes; gbOnlyNameCoin="$2"; shift 2;;
								'')						gbUpdateDb=yes; gbOnlyNameCoin=yes; shift 2;;
								*)						gfnCmdShowUsageConfig; shift; exit 1;;
							esac
						;;
						--random)
							case "$2" in
								'yes'|'no')				gbUpdateDb=yes; gbRandomResolvers="$2"; shift 2;;
								'')						gbUpdateDb=yes; gbRandomResolvers=yes; shift 2;;
								*)						gfnCmdShowUsageConfig; shift; exit 1;;
							esac
						;;
						*)
							if [ "$gbUpdateDb" == no ]; then
								gbCommandLine=no
								gbShowMessages=yes
								gfnMenuShowConfig
								gbCommandLine=yes
								gbShowMessages=no
							fi
							break
						;;
					esac
				done

				# Update DB
				if [ "$gbUpdateDb" == yes ]; then
					gfnSaveConfig; shift; break
				fi
			;;
			'help')	gfnCmdShowUsage; exit 0;;
			*)		gfnCmdShowUsage; exit 0;;
		esac
	done
else
	gfnCmdShowUsage; exit 0;
fi

######################################################################
#
# E N D   C O M M A N D   L I N E   M O D E
#
######################################################################

exit 0

##################### LAST LINE ######################################
